# 攻击手段

## 回溯攻击
* Q: 为什么开奖下注不能为同一个函数?
* A: 如果下注和开奖是同一个函数,可以使用合约对下注进行调用,如果合约余额减少则调用revert()回溯状态,这样可以只对中奖交易进行广播.

## 节点攻击
* Q: 为什么开奖转账为同一个函数?
* A: 如果开奖分为得出结果与转账,玩家在某游戏节点下注自己所有余额,并在下注交易打包之前先被打包了一笔余额转账,导致下注开奖都不会真正上链,而转账交易却在游戏节点被广播出来.

## 开奖攻击
* Q: 为什么不能由玩家决定开奖结果?
* A: 其实和回溯攻击是一致的,回溯攻击的本质上是不能由玩家决定开奖结果,限制合约调用开奖合约只是增加了攻击成本,玩家可以使用自有节点有选择性的广播交易,玩家决定开奖结果是不可取的,玩家会想办法只广播对自己有利的交易.

* Q: 为什么不能用过去哈希开奖?
* A: 虽然玩家不能决定开奖结果,采用过去哈希开奖使玩家已知了开奖结果,可以选择性下注.

* Q: 为什么不能使用自增nonce值开奖?
* A: 如果玩家足够多,分布足够广,nonce值看起来是接近不可预测的,然而一旦玩家数不足,nonce值便成为一个确定的值,可以被玩家所预知.哪怕玩家数量足够多,恶意玩家也可以采用阻塞交易的方式,让nonce值变的可预知.

## 打包攻击
* Q: 为什么不建议使用链上数据作为随机数下注?
* A: 打包节点在打包之前对链上数据是完全已知的,如果打包节点作恶,只打包对自己有利的交易,将使得游戏公平性受到影响,甚至整个链不可信.防止打包作恶可以使用一个名为oracle的合约设置开奖随机数,即游戏庄家控制.采用链上数据本质上是将游戏庄家从开发者手里转让给了打包节点.

## 总结
并没有完全去中心化的随机数产生方式,从安全性来看,玩家生产随机数毫无安全性可言,开发者生产随机数靠开发者自觉,打包节点生产随机数靠打包节点自觉.

本游戏随机数方式是未来哈希+自增nonce值,开奖为按照nonce值顺序开奖,这样在只有一个玩家的情况下,单个打包节点也不能通过选择性打包而作恶.这样避开了玩家,开发者,单个节点作恶的可能.